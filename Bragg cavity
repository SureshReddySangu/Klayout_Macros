# ==========================================================
# Bragg / Hole Mirror Generator (FINAL CLEAN VERSION - COMPLETE)
# ==========================================================

import pya
import math

# -----------------------------
# Default Parameters
# -----------------------------
H = 0.6
a = 0.32
mod_rat = 0.25
gap = 0.0
open_cells = 10
unit_cells = 15
close_bragg = 10
sample_dx = 0.002
rad = 0.2
layer_info = (1, 0)
side = "both"
structure_type = "Bragg"
cavity_length = 0.5
# Add these new globals
left_type = "bragg"
right_type = "bragg"
cavity_tapering = "no_tapering"
tapering_type = "apodised"

# ==========================================================
# Utility
# ==========================================================

def compute_total_cells():
    return open_cells + unit_cells + close_bragg

def envelope_rate(n, total_cells):
    if n < open_cells:
        return float(n) / open_cells * mod_rat # 0 → mod_rat
    elif n < open_cells + unit_cells:
        return mod_rat # plateau
    else:
        remaining = total_cells - (open_cells + unit_cells)
        progress = float(n - (open_cells + unit_cells)) / remaining
        return mod_rat * (1.0 - progress) # mod_rat → 0

def hole_envelope(n, open_cells, unit_cells, close_bragg):
    """
    NEW: Always ramps 0→1→0 - ignores mod_rat
    """
    total_cells = open_cells + unit_cells + close_bragg

    if n < open_cells:
        return float(n) / open_cells # 0 → 1
    elif n < open_cells + unit_cells:
        return 1.0 # PLATEAU at 1.0
    else:
        down_progress = float(n - (open_cells + unit_cells)) / close_bragg
        return 1.0 - down_progress

# ==========================================================
# Bragg Modulation
# ==========================================================

def generate_bragg_polygon(total_cells):
    L = a * total_cells
    steps = int(L / sample_dx)

    upper = []
    lower = []

    for i in range(steps + 1):
        x = i * sample_dx
        if x > L:
            x = L

        cell_index = min(int(x / a), total_cells - 1)
        x_rel = x - cell_index * a

        rate = envelope_rate(cell_index, total_cells)
        h = H/2 + rate * math.sin(2 * math.pi * x_rel / a)
        h = max(0.0, h)

        upper.append((x, gap/2 + h))
        lower.append((x, -gap/2 - h))

    lower.reverse()
    return upper + lower

# ==========================================================
# Hole Logic (Your Exact Method Converted to KLayout)
# ==========================================================

def generate_holes(layout, side_param="both"):
    total_cells = compute_total_cells()
    L = a * total_cells
    dbu = layout.dbu
    main_layer = layout.layer(*layer_info)
    cell = layout.top_cell()

    print(f"DEBUG: rad={rad}, open={open_cells}, unit={unit_cells}, close={close_bragg}")

    for n in range(total_cells):
        x_cell = n * a
        envelope = hole_envelope(n, open_cells, unit_cells, close_bragg)
        radius = max(0.1, rad * envelope)

        print(f"Hole {n}: envelope={envelope:.3f}, radius={radius:.3f}μm")

        positions = []
        if side_param in ["left", "both"]:
            positions.append(0)  # Left mirror at x=0
        
        if side_param in ["right", "both"]:
            # **FIXED: ALWAYS shift by cavity_length for right side**
            shift = L + cavity_length  
            positions.append(shift)

        for base_x in positions:
            x_pos = base_x + x_cell
            r_dbu = int(radius / dbu)
            x_dbu = int(x_pos / dbu)
            y_dbu = 0

            hole_box = pya.Box(x_dbu - r_dbu, y_dbu - r_dbu,
                             x_dbu + r_dbu, y_dbu + r_dbu)
            hole = pya.Polygon.ellipse(hole_box, 32)
            cell.shapes(main_layer).insert(hole)
    
    print(f"Total cells: {compute_total_cells()}")
    print(f"Holes per mirror: {compute_total_cells()}")
    print(f"Side: {side_param}, Right shift: {L + cavity_length}")


def generate_holes_left_only(layout):
    """Holes only on left side"""
    generate_holes(layout, "left")

def generate_holes_right_only(layout):
    """Holes only on right side"""
    generate_holes(layout, "right")

def create_apodised_tapering(layout, L_mirror):
    print("Apodised tapering - TODO")
    # Implementation placeholder

def create_cubic_tapering(layout, L_mirror):
    print("Cubic tapering - TODO")
    # Implementation placeholder

# ==========================================================
# Cavity Creation
# ==========================================================
def create_cavity(layout):
    """Create cavity rectangle between mirrors - CENTERED VERTICALLY"""
    dbu = layout.dbu
    layer = layout.layer(*layer_info)
    cell = layout.top_cell()

    total_cells = open_cells + unit_cells + close_bragg
    L_mirror = a * total_cells

    if cavity_tapering == "no_tapering":
        # **FIXED: Center vertically like Bragg mirrors**
        x1 = int(L_mirror / dbu)
        x2 = int((L_mirror + cavity_length) / dbu)
        y_bottom = int(-H / 2 / dbu)      # Match Bragg lower edge
        y_top = int(H / 2 / dbu)          # Match Bragg upper edge
        rect = pya.Box(x1, y_bottom, x2, y_top)
        cell.shapes(layer).insert(rect)
    else:
        if tapering_type == "apodised":
            create_apodised_tapering(layout, L_mirror)
        elif tapering_type == "cubic":
            create_cubic_tapering(layout, L_mirror)


# ==========================================================
# Structure Creation
# ==========================================================

def create_structure(layout):
    """Main Structure Creation Logic (inside show_dialog)"""
    dbu = layout.dbu
    layer = layout.layer(*layer_info)
    cell = layout.top_cell()

    total_cells = open_cells + unit_cells + close_bragg
    L = a * total_cells

    # LEFT SIDE
    if left_type == "bragg":
        poly_pts = generate_bragg_polygon(total_cells)
        pts = [pya.Point(int(x/dbu), int(y/dbu)) for x, y in poly_pts]
        cell.shapes(layer).insert(pya.Polygon(pts))
    else: # hole
        generate_holes_left_only(layout)

    # CAVITY
    create_cavity(layout)

    # RIGHT SIDE
    if right_type == "bragg":
        shift = L + cavity_length
        mirrored = [(shift + (L - x), y) for x, y in generate_bragg_polygon(total_cells)]
        pts = [pya.Point(int(x/dbu), int(y/dbu)) for x, y in mirrored]
        cell.shapes(layer).insert(pya.Polygon(pts))
    else:
        generate_holes_right_only(layout)

from PyQt5.QtGui import QPainter, QColor
from PyQt5.QtCore import QRect

# -------------------------------
# Preview Widget Class
# -------------------------------
class PreviewWidget(pya.QWidget):
    def __init__(self):
        super().__init__()
        self.setMinimumSize(200, 200) # Minimum size for the preview box
        self.structure_data = None # Placeholder for structure data to be drawn

    def set_structure_data(self, structure_data):
        self.structure_data = structure_data
        self.update() # Repaint the widget with new structure data

    def paintEvent(self, event):
        if not self.structure_data:
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setPen(QColor(0, 0, 0)) # Black color for outline
        painter.setBrush(QColor(150, 150, 150, 50)) # Light grey fill for preview

        # Draw the structure based on the data (structure_data should be a list of points/polygons)
        for shape in self.structure_data:
            if isinstance(shape, list): # List of points (Bragg cells or holes)
                polygon = pya.Polygon([pya.Point(int(x), int(y)) for x, y in shape])
                painter.drawPolygon(polygon)
            elif isinstance(shape, tuple): # Single rectangular shape
                rect = shape
                painter.drawRect(rect[0], rect[1], rect[2], rect[3]) # Draw the outline box

        painter.end()

# ==========================================================
# Dialog (Clean Layout + Conditional Cavity Field)
# ==========================================================
def show_dialog():
    # GLOBAL DECLARATIONS MUST BE FIRST - BEFORE ANY USE
    global H, a, mod_rat, gap
    global open_cells, unit_cells, close_bragg
    global sample_dx, rad, layer_info
    global side, structure_type, cavity_length
    global left_type, right_type, cavity_tapering, tapering_type

    dialog = pya.QDialog()
    dialog.setWindowTitle("Bragg / Hole Mirror Generator")

    main_layout = pya.QVBoxLayout()
    form = pya.QFormLayout()

    # Structure radio buttons - NEW "mixed" option
    bragg_radio = pya.QRadioButton("Bragg")
    hole_radio = pya.QRadioButton("Hole")
    mixed_radio = pya.QRadioButton("Mixed")
    bragg_radio.setChecked(True)

    radio_layout = pya.QHBoxLayout()
    radio_layout.addWidget(bragg_radio)
    radio_layout.addWidget(hole_radio)
    radio_layout.addWidget(mixed_radio)

    # Mixed mode dropdowns (initially hidden)
    left_combo = pya.QComboBox()
    left_combo.addItems(["bragg", "hole"])
    left_combo.setCurrentText("bragg")

    right_combo = pya.QComboBox()
    right_combo.addItems(["bragg", "hole"])
    right_combo.setCurrentText("bragg")

    left_label = pya.QLabel("Left:")
    right_label = pya.QLabel("Right:")

    # Cavity tapering options (initially hidden)
    tapering_radio = pya.QRadioButton("No Tapering")
    tapering_yes_radio = pya.QRadioButton("Tapering")
    tapering_radio.setChecked(True)

    tapering_combo = pya.QComboBox()
    tapering_combo.addItems(["apodised", "cubic"])
    tapering_combo.setCurrentText("apodised")

    tapering_layout = pya.QHBoxLayout()
    tapering_layout.addWidget(tapering_radio)
    tapering_layout.addWidget(tapering_yes_radio)
    tapering_layout.addWidget(tapering_combo)

    # Side selection - SAFE NAME
    side_selector = pya.QComboBox()
    side_selector.addItems(["both", "left", "right"])

    # Inputs for common fields (Bragg and Hole)
    H_edit = pya.QLineEdit(str(H))
    a_edit = pya.QLineEdit(str(a))
    mod_edit = pya.QLineEdit(str(mod_rat))
    open_edit = pya.QLineEdit(str(open_cells))
    unit_edit = pya.QLineEdit(str(unit_cells))
    close_edit = pya.QLineEdit(str(close_bragg))
    total_label = pya.QLabel(str(compute_total_cells()))
    gap_edit = pya.QLineEdit(str(gap))
    sample_dx_edit = pya.QLineEdit(str(sample_dx))
    cavity_label = pya.QLabel("Cavity Length (µm):")
    cavity_edit = pya.QLineEdit(str(cavity_length))

    # Inputs for Hole Modulation fields
    rad_edit = pya.QLineEdit(str(rad))
    layer_edit = pya.QLineEdit(f"{layer_info[0]},{layer_info[1]}")

    # Update total cells label
    def update_total():
        try:
            total = int(open_edit.text()) + int(unit_edit.text()) + int(close_edit.text())
            total_label.setText(str(total))
        except:
            total_label.setText("Invalid")

    open_edit.editingFinished.connect(update_total)
    unit_edit.editingFinished.connect(update_total)
    close_edit.editingFinished.connect(update_total)

    # FIXED FUNCTIONS - NO GLOBAL CONFLICTS
    def update_cavity_visibility():
        cavity_label.setVisible(True)
        cavity_edit.setVisible(True)

    def update_fields():
        is_mixed = mixed_radio.isChecked()
        is_bragg = bragg_radio.isChecked()
        is_hole = hole_radio.isChecked()

        # Show/hide mixed controls
        left_label.setVisible(is_mixed)
        left_combo.setVisible(is_mixed)
        right_label.setVisible(is_mixed)
        right_combo.setVisible(is_mixed)

        # Show/hide tapering controls
        tapering_layout_widgets = [tapering_radio, tapering_yes_radio, tapering_combo]
        for w in tapering_layout_widgets:
            w.setVisible(True)

        # Common fields always visible
        H_edit.setVisible(True)
        a_edit.setVisible(True)
        mod_edit.setVisible(True)
        open_edit.setVisible(True)
        unit_edit.setVisible(True)
        close_edit.setVisible(True)
        total_label.setVisible(True)

        # Bragg-specific
        gap_edit.setVisible(is_bragg or is_mixed)
        sample_dx_edit.setVisible(is_bragg or is_mixed)

        # Hole-specific
        rad_edit.setVisible(is_hole or is_mixed)
        layer_edit.setVisible(is_hole or is_mixed)

    # Connect tapering combo
    tapering_yes_radio.toggled.connect(lambda: tapering_combo.setVisible(tapering_yes_radio.isChecked()))

    # CONNECT SIGNALS
    side_selector.currentIndexChanged.connect(update_cavity_visibility)
    bragg_radio.toggled.connect(update_fields)
    hole_radio.toggled.connect(update_fields)
    mixed_radio.toggled.connect(update_fields)
    tapering_yes_radio.toggled.connect(update_fields)
    
    update_cavity_visibility()
    update_fields() # Initial call

        # Arrange form nicely - KLAYOUT COMPATIBLE
    form.addRow("Structure:", radio_layout)
    form.addRow(left_label, left_combo)
    form.addRow(right_label, right_combo)
    
    # **FIX: Create QWidget wrapper for tapering_layout**
    tapering_widget = pya.QWidget()
    tapering_widget.setLayout(tapering_layout)
    form.addRow("Cavity Tapering:", tapering_widget)
    
    form.addRow("Side:", side_selector)
    form.addRow("Height (µm):", H_edit)
    form.addRow("Period a (µm):", a_edit)
    form.addRow("Modulation Rate:", mod_edit)
    form.addRow("Open Cells:", open_edit)
    form.addRow("Unit Cells:", unit_edit)
    form.addRow("Close Cells:", close_edit)
    form.addRow("Total Cells:", total_label)
    form.addRow("Gap (µm):", gap_edit)
    form.addRow("Sample DX:", sample_dx_edit)
    form.addRow("Hole Radius:", rad_edit)
    form.addRow("Layer (L,D):", layer_edit)
    form.addRow(cavity_label, cavity_edit)


    main_layout.addLayout(form)

    buttons = pya.QDialogButtonBox(dialog)
    buttons.addButton(pya.QDialogButtonBox.Ok)
    buttons.addButton(pya.QDialogButtonBox.Cancel)
    buttons.accepted.connect(dialog.accept)
    buttons.rejected.connect(dialog.reject)

    main_layout.addWidget(buttons)

    dialog.setLayout(main_layout)
    
    if dialog.exec_() != 1:
        return False
    
    try:
        # Update globals
        H = float(H_edit.text)
        a = float(a_edit.text)
        mod_rat = float(mod_edit.text)
        gap = float(gap_edit.text)
        open_cells = int(open_edit.text)
        unit_cells = int(unit_edit.text)
        close_bragg = int(close_edit.text)
        sample_dx = float(sample_dx_edit.text)
        cavity_length = float(cavity_edit.text)
        rad = float(rad_edit.text)
        layer_info = tuple(map(int, layer_edit.text.split(',')))

        # Configuration
        #left_type = left_combo.currentText
        #right_type = right_combo.currentText
         # **FIX: Set left_type/right_type based on radio selection**
        if bragg_radio.isChecked():
            left_type = "bragg"
            right_type = "bragg"
        elif hole_radio.isChecked():
            left_type = "hole"
            right_type = "hole"
        elif mixed_radio.isChecked():
            left_type = left_combo.currentText()
            right_type = right_combo.currentText()
        cavity_tapering = "tapering" if tapering_yes_radio.isChecked() else "no_tapering"
        if cavity_tapering == "tapering":
            tapering_type = tapering_combo.currentText
        structure_type = "Bragg" if bragg_radio.isChecked() else "Hole"
        side = side_selector.currentText

    except:
        pya.MessageBox.warning("Error", "Invalid input values!", pya.MessageBox.Ok)
        return False

    return True




# ==========================================================
# Main
# ==========================================================

def main():
    view = pya.LayoutView.current()
    if not view:
        pya.MessageBox.warning("No Layout", "Open a layout first!", pya.MessageBox.Ok)
        return

    if not show_dialog():
        return

    layout = view.active_cellview().layout()
    create_structure(layout)  # FIXED: Unified call for all modes

    view.zoom_fit()
    pya.MessageBox.info("Done", "Structure Created Successfully!", pya.MessageBox.Ok)

main()

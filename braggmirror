# ==========================================================
# Bragg / Hole Mirror Generator (FINAL CLEAN VERSION)
# ==========================================================

import pya
import math

# -----------------------------
# Default Parameters
# -----------------------------
H = 0.6
a = 0.32
mod_rat = 0.25
gap = 0.0
open_cells = 10
unit_cells = 15
close_bragg = 10
sample_dx = 0.002
rad = 0.2
layer_info = (1, 0)
side = "both"
structure_type = "Bragg"
cavity_length = 0.5


# ==========================================================
# Utility
# ==========================================================

def compute_total_cells():
    return open_cells + unit_cells + close_bragg
def envelope_rate(n, total_cells):
    if n < open_cells:
        return float(n) / open_cells * mod_rat  # 0 → mod_rat
    elif n < open_cells + unit_cells:
        return mod_rat                         # plateau
    else:
        remaining = total_cells - (open_cells + unit_cells)
        progress = float(n - (open_cells + unit_cells)) / remaining
        return mod_rat * (1.0 - progress)      # mod_rat → 0

def hole_envelope(n, open_cells, unit_cells, close_bragg):
    """
    NEW: Always ramps 0→1→0 - ignores mod_rat
    """
    total_cells = open_cells + unit_cells + close_bragg
    
    if n < open_cells:
        return float(n) / open_cells              # 0 → 1
    elif n < open_cells + unit_cells:
        return 1.0                               # PLATEAU at 1.0
    else:
        down_progress = float(n - (open_cells + unit_cells)) / close_bragg
        return 1.0 - down_progress  

# ==========================================================
# Bragg Modulation
# ==========================================================

def generate_bragg_polygon(total_cells):

    L = a * total_cells
    steps = int(L / sample_dx)

    upper = []
    lower = []

    for i in range(steps + 1):
        x = i * sample_dx
        if x > L:
            x = L

        cell_index = min(int(x / a), total_cells - 1)
        x_rel = x - cell_index * a

        rate = envelope_rate(cell_index, total_cells)
        h = H/2 + rate * math.sin(2 * math.pi * x_rel / a)
        h = max(0.0, h)

        upper.append((x, gap/2 + h))
        lower.append((x, -gap/2 - h))

    lower.reverse()
    return upper + lower


# ==========================================================
# Hole Logic (Your Exact Method Converted to KLayout)
# ==========================================================

def compute_total_cells():
    return open_cells + unit_cells + close_bragg


def generate_holes(layout):
    total_cells = open_cells + unit_cells + close_bragg
    L = a * total_cells
    dbu = layout.dbu
    main_layer = layout.layer(*layer_info)
    cell = layout.top_cell()
    
    print(f"DEBUG: rad={rad}, open={open_cells}, unit={unit_cells}, close={close_bragg}")
    
    for n in range(total_cells):
        x_cell = n * a
        
        # **NEW ENVELOPE - 0→1→0**
        envelope = hole_envelope(n, open_cells, unit_cells, close_bragg)
        radius = max(0.1, rad * envelope)  # Now works!
        
        print(f"Hole {n}: envelope={envelope:.3f}, radius={radius:.3f}μm")
        
        # left/right/both positioning...
        positions = []
        if side in ["left", "both"]:
            positions.append(0)
        if side in ["right", "both"]:
            shift = L + cavity_length if side == "both" else L
            positions.append(shift)
        
        for base_x in positions:
            x_pos = base_x + x_cell
            r_dbu = int(radius / dbu)
            x_dbu = int(x_pos / dbu)
            y_dbu = int(H * 0.5 / dbu)
            
            hole_box = pya.Box(x_dbu - r_dbu, y_dbu - r_dbu, 
                             x_dbu + r_dbu, y_dbu + r_dbu)
            hole = pya.Polygon.ellipse(hole_box, 32)
            cell.shapes(main_layer).insert(hole)
print(f"Total cells: {compute_total_cells()}")
print(f"Holes per mirror: {compute_total_cells()}")
print(f"Side: {side}")



# ==========================================================
# Structure Creation
# ==========================================================

# Main Structure Creation Logic (inside show_dialog)
def create_structure(layout):
    dbu = layout.dbu
    layer = layout.layer(*layer_info)
    cell = layout.top_cell()

    total_cells = compute_total_cells()
    L = a * total_cells

    if structure_type == "Bragg":
        poly_pts = generate_bragg_polygon(total_cells)

        if side in ["left", "both"]:
            pts = [pya.Point(int(x/dbu), int(y/dbu)) for x, y in poly_pts]
            cell.shapes(layer).insert(pya.Polygon(pts))

        if side in ["right", "both"]:
            shift = L
            if side == "both":
                shift = L + cavity_length

            mirrored = [(shift + (L - x), y) for x, y in poly_pts]
            pts = [pya.Point(int(x/dbu), int(y/dbu)) for x, y in mirrored]
            cell.shapes(layer).insert(pya.Polygon(pts))

    else:
        generate_holes(layout)  # Create Hole structure


from PyQt5.QtGui import QPainter, QColor
from PyQt5.QtCore import QRect

# -------------------------------
# Preview Widget Class
# -------------------------------

class PreviewWidget(pya.QWidget):
    def __init__(self):
        super().__init__()
        self.setMinimumSize(200, 200)  # Minimum size for the preview box
        self.structure_data = None  # Placeholder for structure data to be drawn

    def set_structure_data(self, structure_data):
        self.structure_data = structure_data
        self.update()  # Repaint the widget with new structure data

    def paintEvent(self, event):
        if not self.structure_data:
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setPen(QColor(0, 0, 0))  # Black color for outline
        painter.setBrush(QColor(150, 150, 150, 50))  # Light grey fill for preview

        # Draw the structure based on the data (structure_data should be a list of points/polygons)
        for shape in self.structure_data:
            if isinstance(shape, list):  # List of points (Bragg cells or holes)
                polygon = pya.Polygon([pya.Point(int(x), int(y)) for x, y in shape])
                painter.drawPolygon(polygon)
            elif isinstance(shape, tuple):  # Single rectangular shape
                rect = shape
                painter.drawRect(rect[0], rect[1], rect[2], rect[3])  # Draw the outline box

        painter.end()


# ==========================================================
# Dialog (Clean Layout + Conditional Cavity Field)
# ==========================================================

# -------------------------------
# Modify show_dialog function
# -------------------------------

# -------------------------------
# Modify show_dialog function
# -------------------------------

def show_dialog():

    global H, a, mod_rat, gap
    global open_cells, unit_cells, close_bragg
    global sample_dx, rad, layer_info
    global side, structure_type, cavity_length

    dialog = pya.QDialog()
    dialog.setWindowTitle("Bragg / Hole Mirror Generator")

    main_layout = pya.QVBoxLayout()
    form = pya.QFormLayout()

    # Structure radio buttons
    bragg_radio = pya.QRadioButton("Bragg Modulation")
    hole_radio = pya.QRadioButton("Hole Modulation")
    bragg_radio.setChecked(True)

    radio_layout = pya.QHBoxLayout()
    radio_layout.addWidget(bragg_radio)
    radio_layout.addWidget(hole_radio)

    # Side selection
    side_combo = pya.QComboBox()
    side_combo.addItems(["both", "left", "right"])

    # Inputs for common fields (Bragg and Hole)
    H_edit = pya.QLineEdit(str(H))
    a_edit = pya.QLineEdit(str(a))
    mod_edit = pya.QLineEdit(str(mod_rat))
    open_edit = pya.QLineEdit(str(open_cells))
    unit_edit = pya.QLineEdit(str(unit_cells))
    close_edit = pya.QLineEdit(str(close_bragg))
    total_label = pya.QLabel(str(compute_total_cells()))
    gap_edit = pya.QLineEdit(str(gap))  # Only for Bragg
    sample_dx_edit = pya.QLineEdit(str(sample_dx))  # Only for Bragg
    cavity_label = pya.QLabel("Cavity Length (µm):")
    cavity_edit = pya.QLineEdit(str(cavity_length))  # Always visible

    # Inputs for Hole Modulation fields
    rad_edit = pya.QLineEdit(str(rad))
    layer_edit = pya.QLineEdit(f"{layer_info[0]},{layer_info[1]}")

    # Update total cells label
    def update_total():
        try:
            total = int(open_edit.text) + int(unit_edit.text) + int(close_edit.text)
            total_label.setText(str(total))
        except:
            total_label.setText("Invalid")

    open_edit.editingFinished.connect(update_total)
    unit_edit.editingFinished.connect(update_total)
    close_edit.editingFinished.connect(update_total)

    # Hide cavity initially
    cavity_label.setVisible(True)
    cavity_edit.setVisible(True)

    def update_cavity_visibility():
        if side_combo.currentText == "both":
            cavity_label.setVisible(True)
            cavity_edit.setVisible(True)
        else:
            cavity_label.setVisible(True)  # Always visible
            cavity_edit.setVisible(True)  # Always visible

    side_combo.currentIndexChanged.connect(update_cavity_visibility)
    update_cavity_visibility()

    # Show/hide fields based on structure type
    def update_fields():
        if bragg_radio.isChecked():
            # Show Bragg related fields
            gap_edit.setVisible(True)
            sample_dx_edit.setVisible(True)

            # Show common fields
            H_edit.setVisible(True)
            a_edit.setVisible(True)
            mod_edit.setVisible(True)
            open_edit.setVisible(True)
            unit_edit.setVisible(True)
            close_edit.setVisible(True)
            total_label.setVisible(True)

            # Hide Hole related fields
            rad_edit.setVisible(False)
            layer_edit.setVisible(False)

        elif hole_radio.isChecked():
            # Show Hole related fields
            rad_edit.setVisible(True)
            layer_edit.setVisible(True)

            # Show common fields
            H_edit.setVisible(True)
            a_edit.setVisible(True)
            mod_edit.setVisible(True)
            open_edit.setVisible(True)
            unit_edit.setVisible(True)
            close_edit.setVisible(True)
            total_label.setVisible(True)

            # Hide Bragg related fields
            gap_edit.setVisible(False)
            sample_dx_edit.setVisible(False)

    bragg_radio.toggled.connect(update_fields)
    hole_radio.toggled.connect(update_fields)
    update_fields()

    # Arrange form nicely
    form.addRow("Structure:", radio_layout)
    form.addRow("Side:", side_combo)
    form.addRow("Height (µm):", H_edit)
    form.addRow("Period a (µm):", a_edit)
    form.addRow("Modulation Rate:", mod_edit)
    form.addRow("Open Cells:", open_edit)
    form.addRow("Unit Cells:", unit_edit)
    form.addRow("Close Cells:", close_edit)
    form.addRow("Total Cells:", total_label)
    form.addRow("Gap (µm):", gap_edit)
    form.addRow("Sample DX:", sample_dx_edit)
    form.addRow("Hole Radius:", rad_edit)
    form.addRow("Layer (L,D):", layer_edit)
    form.addRow(cavity_label, cavity_edit)

    main_layout.addLayout(form)

    buttons = pya.QDialogButtonBox(dialog)
    buttons.addButton(pya.QDialogButtonBox.Ok)
    buttons.addButton(pya.QDialogButtonBox.Cancel)
    buttons.accepted.connect(dialog.accept)
    buttons.rejected.connect(dialog.reject)

    main_layout.addWidget(buttons)
    dialog.setLayout(main_layout)

    if dialog.exec_() != 1:
        return False



    try:
        # Get values based on selected modulation type
        #if bragg_radio.isChecked():
        H = float(H_edit.text)  # Correct use of .text
        a = float(a_edit.text)  # Correct use of .text
        mod_rat = float(mod_edit.text)  # Correct use of .text
        gap = float(gap_edit.text)  # Correct use of .text
        open_cells = int(open_edit.text)  # Correct use of .text
        unit_cells = int(unit_edit.text)  # Correct use of .text
        close_bragg = int(close_edit.text)  # Correct use of .text
        sample_dx = float(sample_dx_edit.text)  # Correct use of .text
        cavity_length = float(cavity_edit.text)  # Correct use of .text
        #else:
        rad = float(rad_edit.text)  # Correct use of .text
        layer_info = tuple(map(int, layer_edit.text.split(',')))  # Correct use of .text

        
    except:
        pya.MessageBox.warning("Error", "Invalid input values!", pya.MessageBox.Ok)
        return False
    structure_type = "Bragg" if bragg_radio.isChecked() else "Hole"
    side = side_combo.currentText
    
    # Now apply the modifications in KLayout
    layout = pya.LayoutView.current().active_cellview().layout()
    if structure_type == "Bragg":
        create_structure(layout)  # Create Bragg structure
    else:
        generate_holes(layout)

    return True


# ==========================================================
# Main
# ==========================================================

def main():

    view = pya.LayoutView.current()
    if not view:
        pya.MessageBox.warning("No Layout", "Open a layout first!", pya.MessageBox.Ok)
        return

    if not show_dialog():
        return

    layout = view.active_cellview().layout()
    create_structure(layout)

    view.zoom_fit()
    pya.MessageBox.info("Done", "Structure Created Successfully!", pya.MessageBox.Ok)


main()

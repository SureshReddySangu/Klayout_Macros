<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># ==========================================================
# EBL Write Time Calculator (JEOL-9500 Excel-Based Estimator)
# UI polish + constraint highlight:
#   - Per-group beam pitch (Shot A units) + computed pitch [nm]
#   - Compact layer lists (left), info grid (right)
#   - Status/advice banner if f &gt; 200 MHz or shot time &lt; 5 ns
#   - Threshold current note
# Notes:
#   - All QLineEdit reads use `.text` (NO parentheses) per your environment
#   - Areas from active cell only (non-recursive)
#   - Time per group: seconds = min_dose[µC/cm²] * area[mm²] / current[nA] * 10
#   - Cost in Kr using Rate [Kr/hr]
# ==========================================================

import pya
import math

FREQ_MAX_HZ = 200_000_000.0   # 200 MHz (JEOL-9500 limit)  [Excel sheet]
MIN_SHOT_NS = 5.0             # 5 ns minimum shot time     [Excel sheet]

class calcWriteTimeEBL(pya.QDialog):
    """
    JEOL-9500 write time estimator with Single/Double current modes,
    per-group beam pitch, compact layer selection + right-side info panel,
    and a status/advice banner when machine limits are violated.
    """

    def __init__(self, parent=None):
        super(calcWriteTimeEBL, self).__init__(parent)
        self._layer_map = {}  # display string -&gt; pya.LayerInfo

        self.initGUI()
        self.initLayout()
        self.initConnection()
        self.populateLayerLists()
        self.updateCurrentModeVisibility()

    # ---------------------------
    # GUI
    # ---------------------------
    def initGUI(self):
        self.setWindowTitle("Write Time Calculator: JEOL-9500")
        self.resize(860, 940)

        # Instruction
        self.labelInstruction = pya.QLabel(
            "This tool estimates JEOL-9500 beam-on write time with machine constraints.\n"
            "Use Single or Double current, choose layers, set Base dose, Minimum modulation, and per-group Beam pitch.",
            self
        )

        # Mode selection
        self.rbSingle = pya.QRadioButton("Single current", self)
        self.rbDouble = pya.QRadioButton("Double currents", self)
        self.rbSingle.setChecked(True)

        # Global inputs
        self.labelMinMod = pya.QLabel("Min. Modulation [%]: ", self)
        self.leMinMod = pya.QLineEdit("0", self)
        self.leMinMod.setFixedWidth(110)
        self.leMinMod.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))

        # ---- Group 1 controls ----
        self.group1Title = pya.QLabel("&lt;b&gt;Group 1&lt;/b&gt;", self)

        self.labelCurrent1 = pya.QLabel("Current 1 [nA]: ", self)
        self.leCurrent1 = pya.QLineEdit("6.0", self)
        self.leCurrent1.setFixedWidth(110)
        self.leCurrent1.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))

        self.labelDose1 = pya.QLabel("Base dose 1 [µC/cm²]: ", self)
        self.leDose1 = pya.QLineEdit("2000", self)
        self.leDose1.setFixedWidth(110)
        self.leDose1.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))

        self.labelPitchUnits1 = pya.QLabel("Beam pitch (Shot A, unit of 0.25 nm): ", self)
        self.lePitchUnits1 = pya.QLineEdit("4", self)  # 4 -&gt; 1.0 nm
        self.lePitchUnits1.setFixedWidth(110)
        self.lePitchUnits1.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))
        self.labelPitchNm1 = pya.QLabel("Beam pitch 1 [nm]:", self)
        self.labelPitchNm1Value = pya.QLabel("", self)

        self.labelLayers1 = pya.QLabel("Layers (Group 1):", self)
        self.layersList1 = pya.QListWidget(self)
        self.layersList1.setSelectionMode(pya.QAbstractItemView.MultiSelection)
        self.layersList1.setMinimumHeight(120)
        self.layersList1.setMaximumWidth(280)

        # Group 1: info grid (right)
        self.labelMinDose1 = pya.QLabel("Minimum dose 1 [µC/cm²]:", self)
        self.labelMinDose1Value = pya.QLabel("", self)
        self.labelFreq1 = pya.QLabel("Scanner frequency 1 [MHz]:", self)
        self.labelFreq1Value = pya.QLabel("", self)
        self.labelShot1 = pya.QLabel("Shot time 1 [ns]:", self)
        self.labelShot1Value = pya.QLabel("", self)
        self.labelIth1 = pya.QLabel("Threshold current 1 [nA]:", self)
        self.labelIth1Value = pya.QLabel("", self)
        self.noteIth1 = pya.QLabel("&lt;i&gt;Threshold current: maximum allowed current at this dose and beam shot.&lt;/i&gt;", self)

        # Group 1: status/advice banner
        self.status1 = pya.QLabel("", self)
        self.status1.setWordWrap(True)
        self.status1.setStyleSheet("QLabel { padding:6px; border-radius:4px; }")

        # ---- Group 2 controls ----
        self.group2Title = pya.QLabel("&lt;b&gt;Group 2&lt;/b&gt;", self)

        self.labelCurrent2 = pya.QLabel("Current 2 [nA]: ", self)
        self.leCurrent2 = pya.QLineEdit("4.0", self)
        self.leCurrent2.setFixedWidth(110)
        self.leCurrent2.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))

        self.labelDose2 = pya.QLabel("Base dose 2 [µC/cm²]: ", self)
        self.leDose2 = pya.QLineEdit("2000", self)
        self.leDose2.setFixedWidth(110)
        self.leDose2.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))

        self.labelPitchUnits2 = pya.QLabel("Beam pitch (Shot A, unit of 0.25 nm): ", self)
        self.lePitchUnits2 = pya.QLineEdit("4", self)
        self.lePitchUnits2.setFixedWidth(110)
        self.lePitchUnits2.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))
        self.labelPitchNm2 = pya.QLabel("Beam pitch 2 [nm]:", self)
        self.labelPitchNm2Value = pya.QLabel("", self)

        self.labelLayers2 = pya.QLabel("Layers (Group 2):", self)
        self.layersList2 = pya.QListWidget(self)
        self.layersList2.setSelectionMode(pya.QAbstractItemView.MultiSelection)
        self.layersList2.setMinimumHeight(120)
        self.layersList2.setMaximumWidth(280)

        self.labelMinDose2 = pya.QLabel("Minimum dose 2 [µC/cm²]:", self)
        self.labelMinDose2Value = pya.QLabel("", self)
        self.labelFreq2 = pya.QLabel("Scanner frequency 2 [MHz]:", self)
        self.labelFreq2Value = pya.QLabel("", self)
        self.labelShot2 = pya.QLabel("Shot time 2 [ns]:", self)
        self.labelShot2Value = pya.QLabel("", self)
        self.labelIth2 = pya.QLabel("Threshold current 2 [nA]:", self)
        self.labelIth2Value = pya.QLabel("", self)
        self.noteIth2 = pya.QLabel("&lt;i&gt;Threshold current: maximum allowed current at this dose and beam shot.&lt;/i&gt;", self)

        self.status2 = pya.QLabel("", self)
        self.status2.setWordWrap(True)
        self.status2.setStyleSheet("QLabel { padding:6px; border-radius:4px; }")

        # Rate and action
        self.labelRateKr = pya.QLabel("Rate [Kr/hr]: ", self)
        self.leRateKr = pya.QLineEdit("600", self)
        self.leRateKr.setFixedWidth(110)
        self.leRateKr.setValidator(pya.QRegExpValidator(pya.QRegExp(r"[0-9\.e\-]*"), self))

        self.bCalc = pya.QPushButton(self)
        self.bCalc.setText("Estimate Write Time")

        # Combined results
        self.labelTotalTime = pya.QLabel("", self)
        self.labelTotalTimeValue = pya.QLabel("", self)
        self.labelCost = pya.QLabel("", self)
        self.labelCostValue = pya.QLabel("", self)
        self.labelLayer = pya.QLabel("", self)
        self.labelArea = pya.QLabel("", self)
        self.labelTime = pya.QLabel("", self)
        mono = pya.QFont("Courier New")
        self.labelLayer.setFont(mono)
        self.labelArea.setFont(mono)
        self.labelTime.setFont(mono)

    def _build_group_panel(self, is_group2=False):
        """
        Compose [Layers (left) | Info + Status (right)] panel for a group.
        """
        wrapper = pya.QWidget(self)
        h = pya.QHBoxLayout(wrapper)

        # Left column: layers
        left_col = pya.QVBoxLayout()
        if not is_group2:
            left_col.addWidget(self.labelLayers1)
            left_col.addWidget(self.layersList1)
        else:
            left_col.addWidget(self.labelLayers2)
            left_col.addWidget(self.layersList2)

        # Right column: info grid + status + threshold note
        right_col = pya.QVBoxLayout()
        grid = pya.QGridLayout()

        if not is_group2:
            row = 0
            grid.addWidget(self.labelMinDose1, row, 0); grid.addWidget(self.labelMinDose1Value, row, 1); row += 1
            grid.addWidget(self.labelFreq1,    row, 0); grid.addWidget(self.labelFreq1Value,    row, 1); row += 1
            grid.addWidget(self.labelShot1,    row, 0); grid.addWidget(self.labelShot1Value,    row, 1); row += 1
            grid.addWidget(self.labelIth1,     row, 0); grid.addWidget(self.labelIth1Value,     row, 1); row += 1
            grid.addWidget(self.labelPitchNm1, row, 0); grid.addWidget(self.labelPitchNm1Value, row, 1); row += 1
            right_col.addLayout(grid)
            right_col.addWidget(self.status1)
            right_col.addWidget(self.noteIth1)
        else:
            row = 0
            grid.addWidget(self.labelMinDose2, row, 0); grid.addWidget(self.labelMinDose2Value, row, 1); row += 1
            grid.addWidget(self.labelFreq2,    row, 0); grid.addWidget(self.labelFreq2Value,    row, 1); row += 1
            grid.addWidget(self.labelShot2,    row, 0); grid.addWidget(self.labelShot2Value,    row, 1); row += 1
            grid.addWidget(self.labelIth2,     row, 0); grid.addWidget(self.labelIth2Value,     row, 1); row += 1
            grid.addWidget(self.labelPitchNm2, row, 0); grid.addWidget(self.labelPitchNm2Value, row, 1); row += 1
            right_col.addLayout(grid)
            right_col.addWidget(self.status2)
            right_col.addWidget(self.noteIth2)

        h.addLayout(left_col, 1)
        h.addLayout(right_col, 1)
        wrapper.setLayout(h)
        return wrapper

    def initLayout(self):
        # Mode row
        hlMode = pya.QHBoxLayout()
        hlMode.addWidget(self.rbSingle)
        hlMode.addWidget(self.rbDouble)
        hlMode.addStretch()

        # Global MinMod row
        hlMinMod = pya.QHBoxLayout()
        hlMinMod.addWidget(self.labelMinMod)
        hlMinMod.addWidget(self.leMinMod)
        hlMinMod.addStretch()

        # Group 1 inputs
        hlG1Inputs = pya.QHBoxLayout()
        hlG1Inputs.addWidget(self.group1Title)
        hlG1Inputs.addSpacing(12)
        hlG1Inputs.addWidget(self.labelCurrent1)
        hlG1Inputs.addWidget(self.leCurrent1)
        hlG1Inputs.addSpacing(12)
        hlG1Inputs.addWidget(self.labelDose1)
        hlG1Inputs.addWidget(self.leDose1)
        hlG1Inputs.addSpacing(12)
        hlG1Inputs.addWidget(self.labelPitchUnits1)
        hlG1Inputs.addWidget(self.lePitchUnits1)
        hlG1Inputs.addSpacing(12)
        hlG1Inputs.addWidget(self.labelPitchNm1)
        hlG1Inputs.addWidget(self.labelPitchNm1Value)
        hlG1Inputs.addStretch()

        self.group1Panel = self._build_group_panel(is_group2=False)

        # Group 2 inputs
        hlG2Inputs = pya.QHBoxLayout()
        hlG2Inputs.addWidget(self.group2Title)
        hlG2Inputs.addSpacing(12)
        hlG2Inputs.addWidget(self.labelCurrent2)
        hlG2Inputs.addWidget(self.leCurrent2)
        hlG2Inputs.addSpacing(12)
        hlG2Inputs.addWidget(self.labelDose2)
        hlG2Inputs.addWidget(self.leDose2)
        hlG2Inputs.addSpacing(12)
        hlG2Inputs.addWidget(self.labelPitchUnits2)
        hlG2Inputs.addWidget(self.lePitchUnits2)
        hlG2Inputs.addSpacing(12)
        hlG2Inputs.addWidget(self.labelPitchNm2)
        hlG2Inputs.addWidget(self.labelPitchNm2Value)
        hlG2Inputs.addStretch()

        self.group2Panel = self._build_group_panel(is_group2=True)

        # Rate row
        hlRate = pya.QHBoxLayout()
        hlRate.addWidget(self.labelRateKr)
        hlRate.addStretch()
        hlRate.addWidget(self.leRateKr)

        # Totals/cost rows
        hlTotalTime = pya.QHBoxLayout()
        hlTotalTime.addWidget(self.labelTotalTime)
        hlTotalTime.addStretch()
        hlTotalTime.addWidget(self.labelTotalTimeValue)

        hlCost = pya.QHBoxLayout()
        hlCost.addWidget(self.labelCost)
        hlCost.addStretch()
        hlCost.addWidget(self.labelCostValue)

        # Results (columns)
        hlResult = pya.QHBoxLayout()
        hlResult.addWidget(self.labelLayer)
        hlResult.addStretch()
        hlResult.addWidget(self.labelArea)
        hlResult.addStretch()
        hlResult.addWidget(self.labelTime)

        # Main layout
        v = pya.QVBoxLayout(self)
        v.addWidget(self.labelInstruction)
        v.addLayout(hlMode)
        v.addLayout(hlMinMod)

        v.addLayout(hlG1Inputs)
        v.addWidget(self.group1Panel)

        v.addLayout(hlG2Inputs)
        v.addWidget(self.group2Panel)

        v.addLayout(hlRate)
        v.addWidget(self.bCalc)
        v.addLayout(hlTotalTime)
        v.addLayout(hlCost)
        v.addLayout(hlResult)

        self.setLayout(v)

    def initConnection(self):
        # Mode toggle
        self.rbSingle.toggled.connect(self.updateCurrentModeVisibility)
        self.rbDouble.toggled.connect(self.updateCurrentModeVisibility)

        # Coercion on edits
        self.leMinMod.editingFinished.connect(self.get_leMinMod)

        self.leCurrent1.editingFinished.connect(self.get_leCurrent1)
        self.leDose1.editingFinished.connect(self.get_leDose1)
        self.lePitchUnits1.editingFinished.connect(self.get_lePitchUnits1)

        self.leCurrent2.editingFinished.connect(self.get_leCurrent2)
        self.leDose2.editingFinished.connect(self.get_leDose2)
        self.lePitchUnits2.editingFinished.connect(self.get_lePitchUnits2)

        self.leRateKr.editingFinished.connect(self.get_leRateKr)

        # Calculate
        self.bCalc.clicked.connect(self.getWriteTime)

    # ---------------------------
    # Helper utils
    # ---------------------------
    def getSecondsToTime(self, seconds):
        try:
            s = int(round(max(0.0, float(seconds))))
        except Exception:
            s = 0
        hours = s // 3600
        s = s % 3600
        minutes = s // 60
        seconds = s % 60
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

    def _get_float(self, le_widget, default, min_val=None, max_val=None):
        try:
            val = float(le_widget.text)
        except Exception:
            val = default
        if (min_val is not None) and (val &lt; min_val):
            val = min_val
        if (max_val is not None) and (val &gt; max_val):
            val = max_val
        le_widget.setText(str(val))
        return val

    def _selected_layers(self, list_widget):
        layers = []
        try:
            items = list_widget.selectedItems()
        except Exception:
            items = []
        for it in items:
            try:
                label = it.text  # NOTE: .text (no parentheses)
            except Exception:
                continue
            if label in self._layer_map:
                layers.append(self._layer_map[label])
        return layers

    # Coercion handlers
    def get_leMinMod(self):         self._get_float(self.leMinMod,       0.0,  0.0, 100.0)
    def get_leCurrent1(self):       self._get_float(self.leCurrent1,     6.0,  0.01, 100.0)
    def get_leDose1(self):          self._get_float(self.leDose1,        2000.0, 1.0, None)
    def get_lePitchUnits1(self):    self._get_float(self.lePitchUnits1,  4.0,  1.0, None)
    def get_leCurrent2(self):       self._get_float(self.leCurrent2,     4.0,  0.01, 100.0)
    def get_leDose2(self):          self._get_float(self.leDose2,        2000.0, 1.0, None)
    def get_lePitchUnits2(self):    self._get_float(self.lePitchUnits2,  4.0,  1.0, None)
    def get_leRateKr(self):         self._get_float(self.leRateKr,       600.0, 1.0, None)

    def updateCurrentModeVisibility(self):
        is_double = self.rbDouble.isChecked()
        self.group2Title.setVisible(is_double)
        self.labelCurrent2.setVisible(is_double)
        self.leCurrent2.setVisible(is_double)
        self.labelDose2.setVisible(is_double)
        self.leDose2.setVisible(is_double)
        self.labelPitchUnits2.setVisible(is_double)
        self.lePitchUnits2.setVisible(is_double)
        self.labelPitchNm2.setVisible(is_double)
        self.labelPitchNm2Value.setVisible(is_double)
        self.group2Panel.setVisible(is_double)
        # Clear status2 when hidden
        if not is_double:
            self.status2.setText("")
            self.status2.setStyleSheet("QLabel { padding:6px; border-radius:4px; }")

    def populateLayerLists(self):
        self._layer_map = {}
        view = pya.LayoutView.current()
        if not view:
            return
        try:
            cv = view.active_cellview()
            layout = cv.layout()
        except Exception:
            return
        if not layout:
            return
        try:
            layers = list(layout.layer_infos())
        except Exception:
            layers = []
        items = []
        for li in layers:
            try:
                s = li.to_s()
            except Exception:
                lyr = getattr(li, "layer", "?")
                dt = getattr(li, "datatype", "?")
                s = f"{lyr}/{dt}"
            items.append((s, li))
        items.sort(key=lambda x: x[0])

        self.layersList1.clear()
        self.layersList2.clear()
        for s, li in items:
            self.layersList1.addItem(s)
            self.layersList2.addItem(s)
            self._layer_map[s] = li

    # ---------------------------
    # JEOL-9500 math helpers (from Excel)
    # ---------------------------
    def _beam_pitch_nm(self, units_025nm):
        # Beam pitch (nm) = units × 0.25 nm
        return units_025nm * 0.25

    def _area_per_shot_cm2(self, pitch_nm):
        # 1 nm = 1e-7 cm  =&gt; area_shot_cm2 = (pitch_nm * 1e-7)^2
        pitch_cm = pitch_nm * 1e-7
        return pitch_cm * pitch_cm

    def _min_dose(self, base_dose_uc_cm2, min_mod_percent):
        return max(0.0, base_dose_uc_cm2 * (1.0 - min_mod_percent / 100.0))

    def _charge_per_shot_C(self, min_dose_uc_cm2, area_shot_cm2):
        # q_shot [C] = min_dose [µC/cm²] * 1e-6 * area_shot [cm²]
        return min_dose_uc_cm2 * 1e-6 * area_shot_cm2

    def _scanner_freq_Hz(self, current_nA, q_shot_C):
        # f [Hz] = I / q_shot = (current[nA]*1e-9) / q_shot[C]
        if q_shot_C &lt;= 0.0:
            return 0.0
        return (current_nA * 1e-9) / q_shot_C

    def _threshold_current_nA(self, q_shot_C):
        # Highest current with f &lt;= 200 MHz: I_thr = f_max * q_shot
        return FREQ_MAX_HZ * q_shot_C * 1e9

    def _set_status_banner(self, label_widget, ok):
        """
        Colors the status banner red (action needed) or green (OK).
        """
        if ok:
            label_widget.setStyleSheet(
                "QLabel { background:#e8f7e8; color:#1e4620; border:1px solid #b7e1b7; padding:6px; border-radius:4px; }"
            )
        else:
            label_widget.setStyleSheet(
                "QLabel { background:#ffecec; color:#5f2120; border:1px solid #f5c6c6; padding:6px; border-radius:4px; }"
            )

    # ---------------------------
    # Core calculation
    # ---------------------------
    def getWriteTime(self):
        view = pya.LayoutView.current()
        if view is None:
            pya.QMessageBox.warning(self, "No Layout", "No layout view is active.")
            return

        try:
            cv = view.active_cellview()
            layout = cv.layout()
            cell = cv.cell
        except Exception:
            pya.QMessageBox.warning(self, "No Active Cell", "Active cell not found.")
            return

        if layout is None or cell is None:
            pya.QMessageBox.warning(self, "No Active Cell", "Active cell not found.")
            return

        # Read globals
        min_mod = self._get_float(self.leMinMod, 0.0, 0.0, 100.0)
        rate_kr_per_hr = self._get_float(self.leRateKr, 600.0, 1.0, None)

        # ---- Group 1 ----
        current1 = self._get_float(self.leCurrent1, 6.0, 0.01, 100.0)
        base_dose1 = self._get_float(self.leDose1, 2000.0, 1.0, None)
        pitch_units1 = self._get_float(self.lePitchUnits1, 4.0, 1.0, None)
        pitch_nm1 = self._beam_pitch_nm(pitch_units1)  # units × 0.25 nm (Excel)
        self.labelPitchNm1Value.setText(f"{pitch_nm1:g}")
        area_shot1_cm2 = self._area_per_shot_cm2(pitch_nm1)
        min_dose1 = self._min_dose(base_dose1, min_mod)
        q_shot1_C = self._charge_per_shot_C(min_dose1, area_shot1_cm2)
        f1_Hz = self._scanner_freq_Hz(current1, q_shot1_C)
        shot1_ns = 1e9 / f1_Hz if f1_Hz &gt; 0 else 0.0
        ith1_nA = self._threshold_current_nA(q_shot1_C) if q_shot1_C &gt; 0 else 0.0

        # ---- Group 2 (optional) ----
        is_double = self.rbDouble.isChecked()
        if is_double:
            current2 = self._get_float(self.leCurrent2, 4.0, 0.01, 100.0)
            base_dose2 = self._get_float(self.leDose2, 2000.0, 1.0, None)
            pitch_units2 = self._get_float(self.lePitchUnits2, 4.0, 1.0, None)
            pitch_nm2 = self._beam_pitch_nm(pitch_units2)
            self.labelPitchNm2Value.setText(f"{pitch_nm2:g}")
            area_shot2_cm2 = self._area_per_shot_cm2(pitch_nm2)
            min_dose2 = self._min_dose(base_dose2, min_mod)
            q_shot2_C = self._charge_per_shot_C(min_dose2, area_shot2_cm2)
            f2_Hz = self._scanner_freq_Hz(current2, q_shot2_C)
            shot2_ns = 1e9 / f2_Hz if f2_Hz &gt; 0 else 0.0
            ith2_nA = self._threshold_current_nA(q_shot2_C) if q_shot2_C &gt; 0 else 0.0
        else:
            current2 = None; base_dose2 = None; pitch_units2 = None
            pitch_nm2 = 0.0; area_shot2_cm2 = 0.0; min_dose2 = 0.0
            q_shot2_C = 0.0; f2_Hz = 0.0; shot2_ns = 0.0; ith2_nA = 0.0

        # ----- Compute selected areas (mm²) -----
        def total_area_mm2_for_layers(layer_infos):
            if not layer_infos:
                return 0.0
            total_um2 = 0.0
            for li in layer_infos:
                try:
                    layer_index = layout.layer(li)
                except Exception:
                    continue
                try:
                    shapes = layout.begin_shapes(cell, layer_index)  # non-recursive
                except Exception:
                    continue
                while not shapes.at_end():
                    try:
                        total_um2 += shapes.shape().darea()
                    except Exception:
                        pass
                    shapes.next()
            return total_um2 / 1_000_000.0  # µm² -&gt; mm²

        layers1 = self._selected_layers(self.layersList1)
        layers2 = self._selected_layers(self.layersList2) if is_double else []
        area1_mm2 = total_area_mm2_for_layers(layers1)
        area2_mm2 = total_area_mm2_for_layers(layers2) if is_double else 0.0

        # ----- Effective current cap via threshold (enforce f &lt;= 200 MHz; ≡ shot &gt;= 5 ns) -----
        eff_current1 = min(current1, ith1_nA) if ith1_nA &gt; 0 else current1
        eff_current2 = min(current2, ith2_nA) if (is_double and ith2_nA &gt; 0) else (current2 if is_double else None)

        # ----- Write times (seconds) -----
        # seconds = min_dose[µC/cm²] * area[mm²] / current[nA] * 10
        t1_s = (min_dose1 * area1_mm2 / max(eff_current1, 1e-12)) * 10.0 if area1_mm2 &gt; 0 else 0.0
        t2_s = (min_dose2 * area2_mm2 / max(eff_current2, 1e-12)) * 10.0 if (is_double and area2_mm2 &gt; 0 and eff_current2 is not None) else 0.0
        t_total_s = t1_s + t2_s

        # ----- Per-group info labels -----
        self.labelMinDose1Value.setText(f"{min_dose1:g}")
        self.labelFreq1Value.setText(f"{f1_Hz/1e6:0.3f}")
        self.labelShot1Value.setText(f"{shot1_ns:0.3f}")
        self.labelIth1Value.setText(f"{ith1_nA:0.3f}")

        if is_double:
            self.labelMinDose2Value.setText(f"{min_dose2:g}")
            self.labelFreq2Value.setText(f"{f2_Hz/1e6:0.3f}")
            self.labelShot2Value.setText(f"{shot2_ns:0.3f}")
            self.labelIth2Value.setText(f"{ith2_nA:0.3f}")
        else:
            self.labelMinDose2Value.setText("")
            self.labelFreq2Value.setText("")
            self.labelShot2Value.setText("")
            self.labelIth2Value.setText("")
            self.labelPitchNm2Value.setText("")
            self.status2.setText("")
            self._set_status_banner(self.status2, True)

        # ----- Status/advice banners -----
        # Violation if f &gt; 200 MHz or shot &lt; 5 ns (from your JEOL sheet)  [1](https://alumni-my.sharepoint.com/personal/nfv144_ku_dk/_layouts/15/Doc.aspx?sourcedoc=%7B3E953E31-2F57-44B0-8921-82A44D58A7BD%7D&amp;file=WritingTimeEstimator.xlsx&amp;action=default&amp;mobileredirect=true)
        def advice_text(group_name):
            return (f"&lt;b&gt;{group_name} — Action needed:&lt;/b&gt; Scanner frequency exceeds 200&amp;nbsp;MHz or shot time is below 5&amp;nbsp;ns.&lt;br&gt;"
                    f"Adjust parameters: &lt;b&gt;increase beam pitch&lt;/b&gt; or &lt;b&gt;increase dose&lt;/b&gt;, or &lt;b&gt;reduce current&lt;/b&gt;.&lt;br&gt;"
                    f"If current and dose must stay fixed, &lt;b&gt;increase beam pitch&lt;/b&gt;.")

        g1_violation = (f1_Hz &gt; FREQ_MAX_HZ) or (0 &lt; shot1_ns &lt; MIN_SHOT_NS)
        if g1_violation:
            self.status1.setText(advice_text("Group 1"))
            self._set_status_banner(self.status1, False)
        else:
            self.status1.setText("Group 1 — OK: within 200 MHz / ≥ 5 ns limits.")
            self._set_status_banner(self.status1, True)

        if is_double:
            g2_violation = (f2_Hz &gt; FREQ_MAX_HZ) or (0 &lt; shot2_ns &lt; MIN_SHOT_NS)
            if g2_violation:
                self.status2.setText(advice_text("Group 2"))
                self._set_status_banner(self.status2, False)
            else:
                self.status2.setText("Group 2 — OK: within 200 MHz / ≥ 5 ns limits.")
                self._set_status_banner(self.status2, True)

        # ----- Combined results (group totals) -----
        layerText = "Selection"
        areaText  = "Area [mm²]"
        timeText  = "Write Time"
        if area1_mm2 &gt; 0:
            layerText += "\nGroup 1"
            areaText  += "\n" + f"{area1_mm2:0.6f}"
            timeText  += "\n" + self.getSecondsToTime(t1_s)
        if is_double and area2_mm2 &gt; 0:
            layerText += "\nGroup 2"
            areaText  += "\n" + f"{area2_mm2:0.6f}"
            timeText  += "\n" + self.getSecondsToTime(t2_s)

        tArea = area1_mm2 + area2_mm2
        layerText += "\nTotal"
        areaText  += "\n" + f"{tArea:0.6f}"
        timeText  += "\n" + self.getSecondsToTime(t_total_s)

        # Cost in Kr
        cost_kr = (t_total_s / 3600.0) * rate_kr_per_hr

        # Display
        self.labelTotalTime.setText("Estimated Print Time [hh:mm:ss]")
        self.labelTotalTimeValue.setText(self.getSecondsToTime(t_total_s))
        self.labelCost.setText("Estimated Print Cost [Kr]")
        self.labelCostValue.setText(f"{cost_kr:.2f}")
        self.labelLayer.setText(layerText)
        self.labelArea.setText(areaText)
        self.labelTime.setText(timeText)

        self.bCalc.setText("Estimate Write Time")
        self.repaint()


# Create and show dialog
dialog = calcWriteTimeEBL(pya.Application.instance().main_window())
dialog.show()</text>
</klayout-macro>
